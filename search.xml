<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>707. 设计链表</title>
      <link href="2021/06/07/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/07/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>*get(index)*：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回<code>-1</code>。</li><li>*addAtHead(val)*：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>*addAtTail(val)*：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>*addAtIndex(index,val)*：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>*deleteAtIndex(index)*：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code> 个节点。</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedList linkedList = new MyLinkedList();</span><br><span class="line">linkedList.addAtHead(1);</span><br><span class="line">linkedList.addAtTail(3);</span><br><span class="line">linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3</span><br><span class="line">linkedList.get(1);            //返回2</span><br><span class="line">linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3</span><br><span class="line">linkedList.get(1);            //返回3</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="方法一-单向链表"><a href="#方法一-单向链表" class="headerlink" title="方法一 单向链表"></a>方法一 单向链表</h3><h4 id="单向链表的节点"><a href="#单向链表的节点" class="headerlink" title="单向链表的节点"></a>单向链表的节点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="单向链表节点的增加"><a href="#单向链表节点的增加" class="headerlink" title="单向链表节点的增加"></a>单向链表节点的增加</h4><ul><li>找到插入位置的前一个节点cur</li><li>将插入节点的next指向cur节点的下一个节点</li><li>将cur节点的下一个节点指向插入节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newNode = Node(val)</span><br><span class="line">newNode.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">cur.<span class="built_in">next</span> = newNode</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/b91201cef2d688461b78fdf0c0f7c615bb9978a8cbb77dbb3882a57fc5be8780/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139353133343333312e706e67" alt="链表-添加节点"></p><h4 id="单向链表节点的删除"><a href="#单向链表节点的删除" class="headerlink" title="单向链表节点的删除"></a>单向链表节点的删除</h4><ul><li>找到删除节点的前一个节点cur</li><li>将cur节点指向待删除节点的下一个节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><ul><li>插入和删除的方法直接按照上述逻辑来就行，容易出错的是cur指针是否指向正确的节点</li><li>先定义一个虚拟头节点(哑节点)会更容易处理问题，可以简化对头节点的操作</li><li>增加头节点和尾节点的方法不必要直接写，可以通过插入函数*addAtIndex(0,val)<em>，</em>addAtIndex(self.count,val)*来间接实现，count是节点数量(不包括哑节点)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.val = val</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.head = Node(-<span class="number">1</span>)</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index&gt;=<span class="number">0</span> <span class="keyword">and</span> index&lt;self.count:</span><br><span class="line">            cur = self.head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>,val)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(self.count,val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt;= self.count:</span><br><span class="line">            cur = self.head</span><br><span class="line">            newNode = Node(val)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = newNode</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newNode.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = newNode</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index&gt;=<span class="number">0</span> <span class="keyword">and</span> index&lt;self.count:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            self.count -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="方法二-双向链表"><a href="#方法二-双向链表" class="headerlink" title="方法二 双向链表"></a>方法二 双向链表</h3><p>双向链表要比单向链表快的多，因为可以通过判断索引index的位置靠近头部还是尾部来决定是从头节点还是尾节点来搜索待查找的节点。</p><h4 id="双向链表的节点"><a href="#双向链表的节点" class="headerlink" title="双向链表的节点"></a>双向链表的节点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="双向链表节点的增加"><a href="#双向链表节点的增加" class="headerlink" title="双向链表节点的增加"></a>双向链表节点的增加</h4><ul><li>找到插入位置的前一个节点cur</li><li>将新节点的next指向cur节点的next</li><li>将cur节点的下一个节点的prev指向新节点</li><li>将cur节点的next指向新节点</li><li>将新节点的prev指向cur节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">newNode = Node(val)</span><br><span class="line"></span><br><span class="line">newNode.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">cur.<span class="built_in">next</span>.prev = newNode</span><br><span class="line">cur.<span class="built_in">next</span> = newNode</span><br><span class="line">newNode.prev = cur</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/b4e5057ef258b98ea66252cd168cae535419161b28a6d6e5859c405e5585eb1b-file_1578973150914" alt="在这里插入图片描述"></p><h4 id="双向链表节点的删除"><a href="#双向链表节点的删除" class="headerlink" title="双向链表节点的删除"></a>双向链表节点的删除</h4><ul><li>找到待删除节点的前一个节点cur</li><li>将节点cur的next指向待删除节点的next</li><li>将待删除节点的下一个节点（由于上一步，此时也是cur的下一个节点）的prev指向cur</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">cur.<span class="built_in">next</span>.prve = cur</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/323a5bf16db256a4267fb8e379606ab54f73e9f6c95db4980f4fdd5bf4f57a08-file_1578973150887" alt="在这里插入图片描述"></p><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><ul><li>双向链表明显比单向链表更快</li><li>双向链表可以设置虚拟的头节点和尾节点来简化代码</li><li>关键步骤依旧是找到待增加/删除位置的前一个节点，然后进行对应得增加、删除或取值操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.val = val</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.head = Node(-<span class="number">1</span>)</span><br><span class="line">        self.tail = Node(-<span class="number">1</span>)</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.pre = self.head</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">0</span> <span class="keyword">or</span> index&gt;=self.count:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index&lt;self.count/<span class="number">2</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index+<span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.count-index):</span><br><span class="line">                cur = cur.pre</span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>,val)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(self.count,val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index&gt;self.count:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">0</span>:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> index&lt;self.count/<span class="number">2</span>:</span><br><span class="line">            cur=self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.count-index+<span class="number">1</span>):</span><br><span class="line">                cur = cur.pre</span><br><span class="line">        </span><br><span class="line">        newNode = Node(val)</span><br><span class="line">        newNode.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span>.pre = newNode</span><br><span class="line">        cur.<span class="built_in">next</span> = newNode</span><br><span class="line">        newNode.pre = cur</span><br><span class="line">        </span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index&gt;=self.count <span class="keyword">or</span> index&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index&lt;self.count/<span class="number">2</span>:</span><br><span class="line">            cur=self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.count-index+<span class="number">1</span>):</span><br><span class="line">                cur = cur.pre</span><br><span class="line">                </span><br><span class="line">        cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span>.pre = cur</span><br><span class="line">        self.count -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/solution/she-ji-lian-biao-by-leetcode/">设计链表 - 设计链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.md">leetcode-master/0707.设计链表.md at master · youngyangyang04/leetcode-master (github.com)</a></p><h2 id="Postscript"><a href="#Postscript" class="headerlink" title="Postscript"></a>Postscript</h2><p>Sentinel：本意是哨兵，在这是哨兵节点</p><p>Sentinel head：也就是虚拟头节点</p><p>Sentinel tail：虚拟尾节点</p><p>prev：previous的缩写，指向前一个节点</p><p>next：指向后一个节点</p><p>pred：predecessor前一个节点</p><p>succ：successor后一个节点</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. 反转链表</title>
      <link href="2021/06/06/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/06/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例一</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例二</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例三</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="方法一：迭代-三指针"><a href="#方法一：迭代-三指针" class="headerlink" title="方法一：迭代+三指针"></a>方法一：迭代+三指针</h3><p>需要三个指针(有些题解叫双指针，但我感觉三指针更准确些)pre、cur、nex分别指向前一个节点、当前节点和下一个节点。</p><p>pre初始值None，cur初始指着头节点、nex初始则是头节点的下一个节点。</p><p>每次操作如下：</p><ul><li>cur将下一个节点指向pre，实现局部的链表反转</li><li>pre和cur往后移动一个节点</li><li>nex是一个临时存储节点的变量。第一步cur将下一个节点指向pre时会失去移动的方向，这个时候就直接用nex来帮助cur移动</li></ul><p><img src="https://camo.githubusercontent.com/36cf9298bccf54091dbcabb9ede884bf98d5b2f6f04bd89a36ac2904b26d0971/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676e7266316f626f757067333067793063343471702e676966" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            nex = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nex</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><p><strong>评论区大佬的超级精简版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p, rev = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            rev, rev.<span class="built_in">next</span>, p = p, rev, p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> rev</span><br></pre></td></tr></table></figure><h3 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h3><p>做了几题发现，链表使用递归是比较常见的作法。</p><p>有几个问题(我遇到的)需要注意：</p><ul><li>递归反转如何避免成环。</li><li>新的头节点怎么找到。</li></ul><p>考虑上述问题后的步骤：</p><ul><li><p>递归到最后一个节点，将该节点设置为新的头节点，并作为函数的返回值</p></li><li><p>在回溯的过程中，将当前节点的下一个节点的next指针指向当前节点实现反转</p></li><li><p>为了避免成环，将当前节点的下一个节点(此时还指向原来的下一个节点)指向None/null(缺少这一步，在回溯过程结束时会导致原链表的头节点区域成环，比如应该是1&lt;-2&lt;-3&lt;-4&lt;-5，结果是1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，这样程序就困在环里直到超时)</p><p><img src="https://pic.leetcode-cn.com/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        newhead = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> newhead</span><br></pre></td></tr></table></figure><p><strong>需要注意newhead这个节点，在最后一次迭代得到了新的头节点后，在回溯过程中是不变的。</strong></p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/">【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.md">leetcode-master/0206.翻转链表.md at master · youngyangyang04/leetcode-master (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203. 移除链表元素</title>
      <link href="2021/06/05/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>2021/06/05/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p><p><strong>示例一</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例二</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例三</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="方法1-1：设置哑节点-dummy-，然后直接迭代"><a href="#方法1-1：设置哑节点-dummy-，然后直接迭代" class="headerlink" title="方法1-1：设置哑节点(dummy)，然后直接迭代"></a>方法1-1：设置哑节点(dummy)，然后直接迭代</h3><p>哑节点是一个虚拟的头节点，在这一题里面，头节点是可能被删除的，删除后的头节点还要考虑需不需要删除；或者当指针往后迭代的过程中，头节点就找不到了，没办法之间返回头节点，这个时候设置哑节点可以有效的解决这些麻烦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        vhead = ListNode(-<span class="number">1</span>,head)<span class="comment">#设置哑节点</span></span><br><span class="line">        p = vhead<span class="comment">#这是移动指针，指向当前要处理的节点</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> (p.<span class="built_in">next</span>).val == val:</span><br><span class="line">                p.<span class="built_in">next</span> = (p.<span class="built_in">next</span>).<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> vhead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h3 id="方法1-2：还是设置哑节点-双指针"><a href="#方法1-2：还是设置哑节点-双指针" class="headerlink" title="方法1-2：还是设置哑节点+双指针"></a>方法1-2：还是设置哑节点+双指针</h3><p>和方法1-1没啥区别，个人感觉双指针直观上好理解一点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        vhead = ListNode(-<span class="number">1</span>,head)</span><br><span class="line">        left = vhead</span><br><span class="line">        right = head</span><br><span class="line">        <span class="keyword">if</span> vhead.<span class="built_in">next</span> == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> right.val == val:</span><br><span class="line">                left.<span class="built_in">next</span> = right.<span class="built_in">next</span></span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = right</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> vhead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h3 id="方法2：递归"><a href="#方法2：递归" class="headerlink" title="方法2：递归"></a>方法2：递归</h3><p><strong>参考了评论区的大佬的思路。</strong>迭代的方法要稍微理解一下，简单来说，对头节点以外的节点进行删除val的操作。递归的中止调节是头节点为空。</p><p><strong>我个人理解：</strong>对链表从前往后看就是把当前节点和后续已经删除了val的链表相连，从后往前看就是链表从后往前删除有val值的节点。</p><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/"><strong>官方的解答文字：</strong></a>链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。这道题要求删除链表中所有节点值等于特定值的节点，可以用递归实现。</p><p>对于给定的链表，首先对除了头节点head以外的节点进行删除操作，然后判断head的节点值是否等于给定的val。如果head的节点值等于val，则head需要被删除，因此删除操作后的头节点为head.next；如果head 的节点值不等于val，则head保留，因此删除操作后的头节点还是head。上述过程是一个递归的过程。</p><p>递归的终止条件是head为空，此时直接返回head。当head不为空时，递归地进行删除操作，然后判断head的节点值是否等于val并决定是否要删除head。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        head.<span class="built_in">next</span> = self.removeElements(head.<span class="built_in">next</span>,val)</span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$，空间复杂度主要取决于递归调用栈，最多不会超过n层。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.md">leetcode-master/0203.移除链表元素.md at master · youngyangyang04/leetcode-master (github.com)</a></p><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/">移除链表元素 - 移除链表元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换与路由总复习第一章</title>
      <link href="2021/06/05/%E4%BA%A4%E6%8D%A2%E4%B8%8E%E8%B7%AF%E7%94%B1%E6%80%BB%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2021/06/05/%E4%BA%A4%E6%8D%A2%E4%B8%8E%E8%B7%AF%E7%94%B1%E6%80%BB%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="交换概论"><a href="#交换概论" class="headerlink" title="交换概论"></a>交换概论</h1><h2 id="基本电信系统"><a href="#基本电信系统" class="headerlink" title="基本电信系统"></a>基本电信系统</h2><p>基本通信系统是用户全互连的通信方式</p><h3 id="多用户全互连通信有何特点？-为什么通信网不直接采用这种方式？"><a href="#多用户全互连通信有何特点？-为什么通信网不直接采用这种方式？" class="headerlink" title="多用户全互连通信有何特点？ 为什么通信网不直接采用这种方式？"></a>多用户全互连通信有何特点？ 为什么通信网不直接采用这种方式？</h3><p><strong>特点：</strong></p><ul><li>若用户终端数为 N， 则两两相连所需的线对数为 $N(N-1)/2$， 所以这种结构所需的线对数将按 $N^2$ 增加， 当 N 很大时， 其复杂度是不能接受的。</li><li>每个用户终端需要配置一个 N-1 路的选择开关。</li></ul><p><strong>缺点：</strong></p><ul><li>两两互连所需的线对数的数量很大， 线路浪费大、 成本高。</li><li> 要配置多路选择开关， 且在主、 被叫终端之间需要复杂的开关控制及选择协调。</li><li>加一个用户终端的操作很复杂。 当增加第 N+1 个终端时， 必须增设 N 条线路，安装维护困难。 当用户终端数 N 较大时， 采用这种方式来实现多个用户之间的通信是不现实的， 根本无法实用化。</li></ul><h2 id="电信网"><a href="#电信网" class="headerlink" title="电信网"></a>电信网</h2><h3 id="使用电信网的原因"><a href="#使用电信网的原因" class="headerlink" title="使用电信网的原因"></a>使用电信网的原因</h3><ul><li>基本电信系统的“$N^2$”问题是必须解决的经济问题</li><li>复用技术能够很好的解决长途传输的效率问题</li><li>寻址技术能够很好的解决长途信道的数量问题</li><li>利用复用技术和寻址技术能够很好的解决“$N^2$”问题</li></ul><h3 id="电信网的结构"><a href="#电信网的结构" class="headerlink" title="电信网的结构"></a>电信网的结构</h3><img src="https://api2.mubu.com/v3/document_image/1b920c78-a76f-4451-8a0b-f91d308c8e61-1279996.jpg" alt="img" style="zoom: 50%;" /><h4 id="电信网的三种支撑网络和主要作用："><a href="#电信网的三种支撑网络和主要作用：" class="headerlink" title="电信网的三种支撑网络和主要作用："></a>电信网的三种支撑网络和主要作用：</h4><ul><li><strong>信令网：</strong><br>信令网是通信网的神经网络，能为现代通信网提供高效、 可靠的信令服务；</li><li><strong>数字同步网：</strong><br>数字同步网能够保证网络中各节点同步工作</li><li><strong>电信管理网：</strong><br>电信管理网 能够全面的、 有效的、 协调的管理整个电信网。</li></ul><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><h3 id="交换的概念"><a href="#交换的概念" class="headerlink" title="交换的概念"></a>交换的概念</h3><p>所谓电信交换，就是在电信网上，在通信的源点和目的点之间建立通信通道，并传送信息的机制。</p><ul><li><strong>选路：</strong><br>每一个交换设备如何选择合适的出线，从而在交换网中建立最佳的从源点到目的点的信息通道</li><li><strong>交换：</strong><br>每个交换设备内部如何将入线的信息送到出线上</li></ul><h3 id="为什么要引入交换功能"><a href="#为什么要引入交换功能" class="headerlink" title="为什么要引入交换功能"></a>为什么要引入交换功能</h3><p>为了克服两两全互连的连接方式所存在的如下 3 个问题：</p><ul><li>两两互连所需的线对数的数量很大， 线路浪费大、 成本高。</li><li>要配置多路选择开关， 且在主、 被叫终端之间需要复杂的开关控制及选择协调。</li><li>增加一个用户终端的操作很复杂。 当增加第 $N+1$ 个终端时， 必须增设$ N$ 条线路，<br>安装维护困难。</li></ul><p>如果在用户分布密集的中心安装一个设备——交换节点（也称为交换机） ， 每个<br>用户的终端设备不再是两两互连， 而是分别经由各自的一条专用通信线路连接到交换节点<br>上。 这时 $N$ 个用户只需要$ N $条电话线， 用户终端无需使用多路选择开关； 当增加新终端时，<br>只需增加一条通信线路。</p><h2 id="复用技术和寻址技术"><a href="#复用技术和寻址技术" class="headerlink" title="复用技术和寻址技术"></a>复用技术和寻址技术</h2><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><ul><li>频分复用</li><li>码分复用</li><li>波分复用</li><li><strong>时分复用（三种时分复用的特点或区别）</strong><ul><li><strong>同步时分复用</strong><ul><li>是位置信道：依据数字信号在时间轴上的位置区别各路信号，无信息传送时也占用信道</li><li>各支路的信息比特率稳定</li><li>信号经过复用器和分路器时会有传输时延，但时延不大。</li></ul></li><li><strong>统计时分复用</strong><ul><li>信息属于哪路取决于标志码，与出现的时间无关；</li><li>分组长度可变，分组头起定界作用；</li><li>统计复用提高信道利用率；</li><li>一定容量的排队存贮器，解决瞬间的出线冲突；</li></ul></li><li><strong>异步时分复用</strong><ul><li>标志化信道：分组长度固定，分组头标志输出端</li><li>统计复用提高信道利用率</li><li>插入空信元保持信元同步</li><li>较小容量的排队存贮器，解决瞬间的出线冲突</li></ul></li></ul></li></ul><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><ul><li><strong>有连接寻址：</strong><br>用户利用人机信令信号，把寻址要求通知信令网；    信令网在信源与信宿之间，利用网络资源建立连接；   然后传递信号；    呼叫结束，信令网释放网络资源。 </li><li><strong>无连接寻址：</strong><br>在各个网络节点，根据信元中的目的地址数据，借助于路由器具有的地址知识，选择通往目的地的链路，在每个节点都进行竞争接入。</li></ul><h2 id="面向连接和无连接的工作方式比较"><a href="#面向连接和无连接的工作方式比较" class="headerlink" title="面向连接和无连接的工作方式比较"></a>面向连接和无连接的工作方式比较</h2><ul><li><strong>面向连接的特点</strong><ul><li>数据传输过程必须经过连接建立、信息传送与释放连接三个阶段</li><li>在呼叫建立时向网络申请资源， 建立一条主叫到被叫之间信息通路的连接， 它是一条物理连接通路</li><li> 只要连接成功就不会发生冲突， 数据传送可靠、 时延小， 且保持传输的顺序。</li></ul></li><li><strong>无连接的特点</strong><ul><li> 每个分组包含完整地址信息，独立寻找路由；</li><li>分组到达的顺序不同， 传输时延大， 时延差别大；</li><li>对网络故障适应性强。</li></ul></li></ul><h2 id="目前通信网中的交换技术"><a href="#目前通信网中的交换技术" class="headerlink" title="目前通信网中的交换技术"></a>目前通信网中的交换技术</h2><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li><li>快速电路交换</li><li>帧中继</li><li>ATM交换</li><li>IP交换</li><li>光交换</li><li>软交换</li></ul><h3 id="电路交换、分组交换和ATM交换的异同"><a href="#电路交换、分组交换和ATM交换的异同" class="headerlink" title="电路交换、分组交换和ATM交换的异同"></a>电路交换、分组交换和ATM交换的异同</h3><table><thead><tr><th align="center"></th><th align="center">工作方式</th><th align="center">复用方式</th><th align="center">差错控制</th><th align="center">流量控制</th><th align="center">带宽分配</th><th align="center">支持的业务</th></tr></thead><tbody><tr><td align="center">电路交换</td><td align="center">面向连接</td><td align="center">同步时分复用</td><td align="center">无</td><td align="center">呼损</td><td align="center">固定分配带宽</td><td align="center">话音</td></tr><tr><td align="center">分组交换</td><td align="center">面向连接和无连接</td><td align="center">统计时分复用</td><td align="center">有</td><td align="center">呼叫延迟</td><td align="center">动态分配带宽</td><td align="center">数据</td></tr><tr><td align="center">ATM 交换</td><td align="center">面向连接</td><td align="center">异步时分复用</td><td align="center">有</td><td align="center">呼叫延迟</td><td align="center">动态分配带宽</td><td align="center">话音、数据、多媒体</td></tr></tbody></table><p><strong>需要注意的是：</strong>经管电路交换、分组交换和ATM交换都可以采用面向连接的方式，但它们是有不同的：</p><ul><li>电路交换的面向连接是物理连接</li><li>分组交换的面向连接是逻辑连接（LCN）</li><li>ATM交换的面向连接是虚连接（VPI和VCI）</li></ul><h3 id="分组交换的两种工作方式的比较"><a href="#分组交换的两种工作方式的比较" class="headerlink" title="分组交换的两种工作方式的比较"></a>分组交换的两种工作方式的比较</h3><ul><li><strong>数据报</strong><ul><li>每个数据分组都包含终点地址信息，独立寻找路径，在网络终点需要重新排序。</li><li>传输时延大，时延差别大，对网络故障适应性强。 </li></ul></li><li><strong>虚电路</strong><ul><li>类似电路交换，通信要经过 连接建立、数据传输、连接拆除 三个阶段</li><li>它不同于电路交换中的物理连接，而是逻辑连接</li><li>分组头中只含有对应于所建立的VC的逻辑信道标识</li><li>传输时延小，时延差别小，分组有序到达，网络故障时要重新连接。</li></ul></li></ul><h3 id="分组交换和中继的区别和联系"><a href="#分组交换和中继的区别和联系" class="headerlink" title="分组交换和中继的区别和联系"></a>分组交换和中继的区别和联系</h3><p><strong>区别</strong></p><table><thead><tr><th align="center"></th><th align="center">帧中继</th><th align="center">分组交换</th></tr></thead><tbody><tr><td align="center">特点</td><td align="center">速率高、时延小</td><td align="center">速率低、时延大</td></tr><tr><td align="center">最小单位</td><td align="center">帧</td><td align="center">分组</td></tr><tr><td align="center">信息传输</td><td align="center">端到端确认信息</td><td align="center">点到点确认信息</td></tr><tr><td align="center">控制信令</td><td align="center">公共信令</td><td align="center">随路信令</td></tr><tr><td align="center">协议栈</td><td align="center">物理层、链路层</td><td align="center">物理层、链路层、网络层</td></tr><tr><td align="center">寻址和选路</td><td align="center">二层（链路层）完成</td><td align="center">三层（分组层）完成</td></tr><tr><td align="center">其他</td><td align="center">网络内部不需要差错控制 传输线必须是光纤</td><td align="center"></td></tr></tbody></table><p><strong>联系</strong></p><ul><li>帧中继是分组交换的改进，都采用面向连接的交换技术</li><li>都可以提供PVC（永久虚拟电路）和SVC（交换虚拟电路）业务</li><li>均采用统计十分复用方式，可以动态分配带宽</li></ul><h4 id="PVC和SVC"><a href="#PVC和SVC" class="headerlink" title="PVC和SVC"></a>PVC和SVC</h4><ul><li><strong>PVC：</strong>应用户预约，由网络运营者为之建立固定的虚电路，而不需在    呼叫时临时建立虚电路，可直接进入数据传送阶段的方式。</li><li><strong>SVC：</strong>用户通过发送呼叫请求分组来建立虚电路的方式。</li></ul><h3 id="帧中继和ATM交换的区别"><a href="#帧中继和ATM交换的区别" class="headerlink" title="帧中继和ATM交换的区别"></a>帧中继和ATM交换的区别</h3><p>ATM 是结合了电路交换和分组交换的优点发展起来的一种技术， 因此， 帧中继是 ATM的基础， 是对帧中继的进一步简化， 并引入了面向连接特性。 二者之间的差异主要在于差错控制上。</p><p><img src="C:\Users\Dogwealth\AppData\Roaming\Typora\typora-user-images\image-20210607195426846.png" alt="image-20210607195426846"></p><h3 id="软交换、NGN和IMS的含义和它们之间的关系"><a href="#软交换、NGN和IMS的含义和它们之间的关系" class="headerlink" title="软交换、NGN和IMS的含义和它们之间的关系"></a>软交换、NGN和IMS的含义和它们之间的关系</h3><p><strong>待跟新。。。</strong></p><h2 id="交换系统的基本结构和主要技术"><a href="#交换系统的基本结构和主要技术" class="headerlink" title="交换系统的基本结构和主要技术"></a>交换系统的基本结构和主要技术</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="C:\Users\Dogwealth\AppData\Roaming\Typora\typora-user-images\image-20210607200901428.png" alt="image-20210607200901428"></p><ul><li><strong>信息传输子系统</strong><br>信息传送子系统主要包括交换网络和各种接口<ul><li><strong>交换网络</strong><br>对于信息传送子系统而言， 交换就是信息从某个接口进入交换系统经交换网络的交换从某个接口出去。</li><li><strong>接口</strong><br>接口的功能主要是将进入交换系统的信号转变为交换系统内部所适应的信号， 或者是相反的过程， 这种变换包括信号码型、 速率等方面的变换。</li></ul></li><li><strong>控制子系统</strong><br>控制子系统是交换系统的“指挥中心” ， 交换系统的交换网络、 各种接口以及其他功能<br>部件都是在控制子系统的控制协调下有条不紊地工作的。</li></ul><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><ul><li><strong>互连技术：</strong>交换网络的拓扑结构、 选路策略、 控制机理、 多播方式、 阻塞特性、 故障防卫；</li><li><strong>接口技术：</strong> 模拟用户接口、 数字用户接口、 模拟中继接口、 数字中继接口；</li><li><strong>信令技术：</strong> 用户信令、 局间信令；</li><li><strong>控制技术：</strong> 控制系统的结构方式、 处理机间的通信方式、 多处理机结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 交换与路由 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交换与路由 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/06/05/hello-world/"/>
      <url>2021/06/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
